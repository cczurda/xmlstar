<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book lang="en">
  <title>XmlStarlet Command Line XML Toolkit User&#39;s Guide</title>

  <bookinfo>
    <date>Nov 24, 2003</date>

    <author>
      <firstname>Mikhail</firstname>

      <surname>Grushinskiy</surname>
    </author>
  </bookinfo>

  <chapter>
    <title id="s.1">Introduction</title>

    <sect1>
      <title id="s.1.1">About XmlStarlet</title>

      <para><ulink url="http://xmlstar.sourceforge.net/">XMLStarlet</ulink> is
      a set of command line utilities (tools) which can be used to transform,
      query, validate, and edit XML documents and files using simple set of
      shell commands in similar way it is done for plain text files using UNIX
      grep, sed, awk, diff, patch, join, etc commands.</para>

      <para>This set of command line utilities can be used by those who deal
      with many XML documents on UNIX shell command prompt as well as for
      automated XML processing with shell scripts.</para>

      <para>XMLStarlet command line utility is written in C and uses libxml2
      and libxslt from <ulink url="http://xmlsoft.org/">http://xmlsoft.org/</ulink>.
      Implementation of extensive choice of options for XMLStarlet utility was
      only possible because of rich feature set of libxml2 and libxslt (many
      thanks to the developers of those libraries for great work).</para>

      <para>&#39;diff&#39; and &#39;patch&#39; options are not currently
      implemented. Other features need some work too. Please, send an email to
      the project administrator (see <ulink
      url="http://sourceforge.net/projects/xmlstar/">http://sourceforge.net/projects/xmlstar/</ulink>)
      if you wish to help.</para>

      <para>XMLStarlet is linked statically to both libxml2 and libxslt, so
      generally all you need to process XML documents is one executable file.
      To run XmlStarlet utility you can simple type &#39;xml&#39; on command
      line and see list of options available.</para>

      <para>XMLStarlet is open source freeware under MIT license which allows
      free use and distribution for both commercial and non-commercial
      projects.</para>

      <para>We welcome any user&#39;s feedback on this project which would
      greatly help us to improve its quality. Comments, suggestions, feature
      requests, bug reports can be done via SourceForge project web site (see
      <ulink url="http://sourceforge.net/forum/?group_id=66612">XMLStarlet
      Sourceforge forums</ulink>, or <ulink
      url="http://lists.sourceforge.net/lists/listinfo/xmlstar-devel/">XMLStarlet
      mailing list</ulink>)</para>
    </sect1>

    <sect1>
      <title id="s.1.2">Main Features</title>

      <para>The toolkit&#39;s feature set includes options to:</para>

      <itemizedlist>
        <listitem>
          <para>Check or validate XML files (simple well-formedness check,
          DTD, XSD, RelaxNG)</para>
        </listitem>

        <listitem>
          <para>Calculate values of XPath expressions on XML files (such as
          running sums, etc)</para>
        </listitem>

        <listitem>
          <para>Search XML files for matches to given XPath expressions</para>
        </listitem>

        <listitem>
          <para>Apply XSLT stylesheets to XML documents (including EXSLT
          support, and passing parameters to stylesheets)</para>
        </listitem>

        <listitem>
          <para>Query XML documents (ex. query for value of some elements of
          attributes, sorting, etc)</para>
        </listitem>

        <listitem>
          <para>Modify or edit XML documents (ex. delete some elements)</para>
        </listitem>

        <listitem>
          <para>Format or &#34;beautify&#34; XML documents (as changing
          indentation, etc)</para>
        </listitem>

        <listitem>
          <para>Fetch XML documents using http:// or ftp:// URLs</para>
        </listitem>

        <listitem>
          <para>Browse tree structure of XML documents (in similar way to
          &#39;ls&#39; command for directories)</para>
        </listitem>

        <listitem>
          <para>Include one XML document into another using XInclude</para>
        </listitem>

        <listitem>
          <para>XML c14n canonicalization</para>
        </listitem>

        <listitem>
          <para>Escape/unescape special XML characters in input text</para>
        </listitem>

        <listitem>
          <para>Print directory as XML document</para>
        </listitem>

        <listitem>
          <para>Convert XML into PYX format (based on ESIS - ISO 8879), and
          vice versa</para>
        </listitem>
      </itemizedlist>

      <para></para>
    </sect1>

    <sect1>
      <title id="s.1.3">Supported Platforms</title>

      <para>Here is a list of platforms on which XmlStarlet is known to work.</para>

      <itemizedlist>
        <listitem>
          <para>Linux</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Solaris</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>Windows</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>MacOS X</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>FreeBSD</para>
        </listitem>
      </itemizedlist>

      <para>You might be able to compile and make it on others too.</para>
    </sect1>
  </chapter>

  <chapter>
    <title id="s.2">Installation</title>

    <sect1>
      <title id="s.2.1">Installation on Linux</title>

      <para>Execute the following command as root<programlisting>rpm -i xmlstarlet-x.x.x-1.i386.rpm</programlisting></para>

      <para>where x.x.x indicates package version.</para>

      <para>You can use <ulink
      url="http://fr2.rpmfind.net/linux/rpm2html/search.php?query=xmlstarlet&#38;system=&#38;arch=">http://rpmfind.net</ulink>
      to search for RPM appropriate for your distribution.</para>
    </sect1>

    <sect1>
      <title id="s.2.2">Installation on Solaris</title>

      <para>Execute the following commands as root<programlisting>gunzip xmlstarlet-x.x.x-sol8-sparc-local.gz
pkgadd -d xmlstarlet-x.x.x-sol8-sparc-local all</programlisting></para>
    </sect1>

    <sect1>
      <title id="s.2.3">Installation on MacOS X</title>

      <para>XmlStarlet is available on MacOS in Fink. <ulink
      url="http://fink.sourceforge.net/pdb/package.php/xmlstarlet">See
      fink.sourceforge.net</ulink></para>
    </sect1>

    <sect1>
      <title id="s.2.4">Installation on Windows</title>

      <para>Unzip the file xmlstarlet-x.x.x-win32.zip to some directory. To
      take advantage of UNIX shell scripting you might want to run XmlStarlet
      from Cygwin. Consider installing <ulink url="http://www.cygwin.com/">Cygwin</ulink>
      on your Windows machine.</para>
    </sect1>
  </chapter>

  <chapter>
    <title id="s.3">Getting Started</title>

    <sect1>
      <title id="s.3.1">Basic Command-Line Options</title>

      <para>Basic command line syntax: <programlisting>bash-2.03$ xml
XMLStarlet Toolkit: Command line utilities for XML
Usage: xml [&#60;options&#62;] &#60;command&#62; [&#60;cmd-options&#62;]
where &#60;command&#62; is one of:
   ed    (or edit)      - Edit/Update XML document(s)
   sel   (or select)    - Select data or query XML document(s) (XPATH, etc)
   tr    (or transform) - Transform XML document(s) using XSLT
   val   (or validate)  - Validate XML document(s) (well-formed/DTD/XSD/RelaxNG)
   fo    (or format)    - Format XML document(s)
   el    (or elements)  - Display element structure of XML document
   c14n  (or canonic)   - XML canonicalization
   ls    (or list)      - List directory as XML
   esc   (or escape)    - Escape special XML characters
   unesc (or unescape)  - Unescape special XML characters
   pyx   (or xmln)      - Convert XML into PYX format (based on ESIS - ISO 8879)
   p2x   (or depyx)     - Convert PYX into XML
&#60;options&#62; are:
   --version            - show version
   --help               - show help
Wherever file name mentioned in command help it is assumed
that URL can be used instead as well.

Type: xml &#60;command&#62; --help &#60;ENTER&#62; for command help

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)</programlisting></para>
    </sect1>

    <sect1>
      <title id="s.3.2">Studying Structure of XML Document</title>

      <para>Before you do anything with your XML document you probably would
      like to know its structure at first. &#39;el&#39; option could be used
      for this purpose.</para>

      <para>Let&#39;s say you have the following XML document (table.xml)</para>

      <programlisting>&#60;xml&#62;
  &#60;table&#62;
    &#60;rec id=&#34;1&#34;&#62;
      &#60;numField&#62;123&#60;/numField&#62;
      &#60;stringField&#62;String Value&#60;/stringField&#62;
    &#60;/rec&#62;
    &#60;rec id=&#34;2&#34;&#62;
      &#60;numField&#62;346&#60;/numField&#62;
      &#60;stringField&#62;Text Value&#60;/stringField&#62;
    &#60;/rec&#62;
    &#60;rec id=&#34;3&#34;&#62;
      &#60;numField&#62;-23&#60;/numField&#62;
      &#60;stringField&#62;stringValue&#60;/stringField&#62;
    &#60;/rec&#62;
  &#60;/table&#62;
&#60;/xml&#62;</programlisting>

      <programlisting>xml el table.xml</programlisting>

      <para>would produce the following output.</para>

      <programlisting>xml
xml/table
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField</programlisting>

      <para>Every line in this output is an XPath expression which indicates a
      &#39;path&#39; to elements in XML document. You would use these XPath
      expressions to navigate through your XML documents in other XmlStarlet
      options.</para>

      <para>XML documents can be pretty large but with a very simple
      structure. (This is espesially true for data driven XML documents ex:
      XML formatted result of select from SQL table). If you just interested
      in structure but not order of the elements you can use -u switch
      combined with &#39;el&#39; option.</para>

      <para>EXAMPLE:</para>

      <programlisting>xml el -u table.xml</programlisting>

      <para>Output:</para>

      <programlisting>xml
xml/table
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField</programlisting>

      <para>If you are interested not just in elements of your XML document,
      but you want to see attributes as well you can use -a switch with
      &#39;el&#39; option. And every line of the output will still be a valid
      XPath expression.</para>

      <para>EXAMPLE:</para>

      <programlisting>xml el -a table.xml</programlisting>

      <para>Output:</para>

      <programlisting>xml
xml/table
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField</programlisting>

      <para>If you are looking for attribute values as well use -v switch of
      &#39;el&#39; option. And again - every line of output is a valid XPath
      expression.</para>

      <para>EXAMPLE:</para>

      <programlisting>xml el -v table.xml</programlisting>

      <para>Output:</para>

      <programlisting>xml
xml/table
xml/table/rec[@id=&#39;1&#39;]
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec[@id=&#39;2&#39;]
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec[@id=&#39;3&#39;]
xml/table/rec/numField
xml/table/rec/stringField</programlisting>
    </sect1>
  </chapter>

  <chapter>
    <title>XmlStarlet Reference</title>

    <para></para>

    <sect1>
      <title>Querying XML documents</title>

      <para>XmlStarlet &#39;select&#39; or &#39;sel&#39; option can be used to
      query or search XML documents. Here is synopsis for &#39;xml sel&#39;
      command:</para>

      <programlisting>XMLStarlet Toolkit: Select from XML document(s)
Usage: xml sel &#60;global-options&#62; {&#60;template&#62;} [ &#60;xml-file&#62; ... ]
where
  &#60;global-options&#62; - global options for selecting
  &#60;xml-file&#62; - input XML document file name/uri (stdin is used if missing)
  &#60;template&#62; - template for querying XML document with following syntax:

&#60;global-options&#62; are:
  -C or --comp       - display generated XSLT
  -R or --root       - print root element &#60;xsl-select&#62;
  -T or --text       - output is text (default is XML)
  -I or --indent     - indent output
  -D or --xml-decl   - do not omit xml declaration line
  -B or --noblanks   - remove insignificant spaces from XML tree
  -N &#60;name&#62;=&#60;value&#62;  - predefine namespaces (name without &#39;xmlns:&#39;)
                       ex: xsql=urn:oracle-xsql
                       Multiple -N options are allowed.
  --net              - allow fetch DTDs or entities over network
  --help             - display help

Syntax for templates: -t|--template &#60;options&#62;
where &#60;options&#62;
  -c or --copy-of &#60;xpath&#62;  - print copy of XPATH expression
  -v or --value-of &#60;xpath&#62; - print value of XPATH expression
  -o or --output &#60;string&#62;  - output string literal
  -n or --nl               - print new line
  -f or --inp-name         - print input file name (or URL)
  -m or --match &#60;xpath&#62;    - match XPATH expression
  -i or --if &#60;test-xpath&#62;  - check condition &#60;xsl:if test=&#34;test-xpath&#34;&#62;
  -e or --elem &#60;name&#62;      - print out element &#60;xsl:element name=&#34;name&#34;&#62;
  -a or --attr &#60;name&#62;      - add attribute &#60;xsl:attribute name=&#34;name&#34;&#62;
  -b or --break            - break nesting
  -s or --sort op xpath    - sort in order (used after -m) where
  op is X:Y:Z,
      X is A - for order=&#34;ascending&#34;
      X is D - for order=&#34;descending&#34;
      Y is N - for data-type=&#34;numeric&#34;
      Y is T - for data-type=&#34;text&#34;
      Z is U - for case-order=&#34;upper-first&#34;
      Z is L - for case-order=&#34;lower-first&#34;

There can be multiple --match, --copy-of, --value-of, etc options
in a single template. The effect of applying command line templates
can be illustrated with the following XSLT analogue

xml sel -t -c &#34;xpath0&#34; -m &#34;xpath1&#34; -m &#34;xpath2&#34; -v &#34;xpath3&#34; \
        -t -m &#34;xpath4&#34; -c &#34;xpath5&#34;

is equivalent to applying the following XSLT

&#60;?xml version=&#34;1.0&#34;?&#62;
&#60;xsl:stylesheet version=&#34;1.0&#34; xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;&#62;
&#60;xsl:template match=&#34;/&#34;&#62;
  &#60;xsl:call-template name=&#34;t1&#34;/&#62;
  &#60;xsl:call-template name=&#34;t2&#34;/&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t1&#34;&#62;
  &#60;xsl:copy-of select=&#34;xpath0&#34;/&#62;
  &#60;xsl:for-each select=&#34;xpath1&#34;&#62;
    &#60;xsl:for-each select=&#34;xpath2&#34;&#62;
      &#60;xsl:value-of select=&#34;xpath3&#34;/&#62;
    &#60;/xsl:for-each&#62;
  &#60;/xsl:for-each&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t2&#34;&#62;
  &#60;xsl:for-each select=&#34;xpath4&#34;&#62;
    &#60;xsl:copy-of select=&#34;xpath5&#34;/&#62;
  &#60;/xsl:for-each&#62;
&#60;/xsl:template&#62;
&#60;/xsl:stylesheet&#62;

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)

Current implementation uses libxslt from GNOME codebase as XSLT processor
(see http://xmlsoft.org/ for more details)
</programlisting>

      <para>&#39;select&#39; option allows you basically avoid writting XSLT
      stylesheet to perform some queries on XML documents. I.e. various
      combinations of command line parameters will let you to generate XSLT
      stylesheet and apply in to XML documents with a single command line.
      Very often you do not really care what XSLT was created for you
      &#39;select&#39; command, but in those cases when you do; you can always
      use -C or --comp switch which will let you see exactly which XSLT is
      applied to your input.</para>

      <para>&#39;select&#39; option supports many EXSLT functions in XPath
      expressions.</para>

      <para>Here are few examples which will help to understand how &#39;xml
      select&#39; works:</para>

      <para>EXAMPLE:</para>

      <para>Count elements matching XPath expression:</para>

      <para></para>

      <programlisting>xml sel -t -v &#34;count(/xml/table/rec/numField)&#34; table.xml</programlisting>

      <para>Input (table.xml):</para>

      <programlisting>&#60;xml&#62;
  &#60;table&#62;
    &#60;rec id=&#34;1&#34;&#62;
      &#60;numField&#62;123&#60;/numField&#62;
      &#60;stringField&#62;String Value&#60;/stringField&#62;
    &#60;/rec&#62;
    &#60;rec id=&#34;2&#34;&#62;
      &#60;numField&#62;346&#60;/numField&#62;
      &#60;stringField&#62;Text Value&#60;/stringField&#62;
    &#60;/rec&#62;
    &#60;rec id=&#34;3&#34;&#62;
      &#60;numField&#62;-23&#60;/numField&#62;
      &#60;stringField&#62;stringValue&#60;/stringField&#62;
    &#60;/rec&#62;
  &#60;/table&#62;
&#60;/xml&#62;</programlisting>

      <para>Output:</para>

      <programlisting>3
</programlisting>

      <para>Let&#39;s take a close look what it did internally. For that we
      will use &#39;-C&#39; option</para>

      <programlisting>$ xml sel -C -t -v &#34;count(/xml/table/rec/numField)&#34;
&#60;?xml version=&#34;1.0&#34;?&#62;
&#60;xsl:stylesheet version=&#34;1.0&#34; xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;
 xmlns:exslt=&#34;http://exslt.org/common&#34;
 xmlns:math=&#34;http://exslt.org/math&#34;
 xmlns:date=&#34;http://exslt.org/dates-and-times&#34;
 xmlns:func=&#34;http://exslt.org/functions&#34;
 xmlns:set=&#34;http://exslt.org/sets&#34;
 xmlns:str=&#34;http://exslt.org/strings&#34;
 xmlns:dyn=&#34;http://exslt.org/dynamic&#34;
 xmlns:saxon=&#34;http://icl.com/saxon&#34;
 xmlns:xalanredirect=&#34;org.apache.xalan.xslt.extensions.Redirect&#34;
 xmlns:xt=&#34;http://www.jclark.com/xt&#34;
 xmlns:libxslt=&#34;http://xmlsoft.org/XSLT/namespace&#34;
 xmlns:test=&#34;http://xmlsoft.org/XSLT/&#34;
 extension-element-prefixes=&#34;exslt math date func set str dyn saxon xalanredirect xt libxslt test&#34;
 exclude-result-prefixes=&#34;math str&#34;&#62;
&#60;xsl:output omit-xml-declaration=&#34;yes&#34; indent=&#34;no&#34;/&#62;
&#60;xsl:param name=&#34;inputFile&#34;&#62;-&#60;/xsl:param&#62;
&#60;xsl:template match=&#34;/&#34;&#62;
  &#60;xsl:call-template name=&#34;t1&#34;/&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t1&#34;&#62;
  &#60;xsl:value-of select=&#34;count(/xml/table/rec/numField)&#34;/&#62;
&#60;/xsl:template&#62;
&#60;/xsl:stylesheet&#62;</programlisting>

      <para>Ignoring some XSLT stuff to make it brief:</para>

      <programlisting>&#60;xsl:stylesheet version=&#34;1.0&#34; xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;&#62;
&#60;xsl:output omit-xml-declaration=&#34;yes&#34; indent=&#34;no&#34;/&#62;
&#60;xsl:param name=&#34;inputFile&#34;&#62;-&#60;/xsl:param&#62;
&#60;xsl:template match=&#34;/&#34;&#62;
  &#60;xsl:call-template name=&#34;t1&#34;/&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t1&#34;&#62;
  &#60;xsl:value-of select=&#34;count(/xml/table/rec/numField)&#34;/&#62;
&#60;/xsl:template&#62;
&#60;/xsl:stylesheet&#62;</programlisting>

      <para>Every -t option is mapped into XSLT template. Options after
      &#39;-t&#39; are mapped into XSLT elements:</para>

      <itemizedlist>
        <listitem>
          <para>-v to &#60;xsl:value-of&#62;</para>
        </listitem>

        <listitem>
          <para>-c to &#60;xsl:copy-of&#62;</para>
        </listitem>

        <listitem>
          <para>-e to &#60;xsl:element&#62;</para>
        </listitem>

        <listitem>
          <para>-a to &#60;xsl:attribute&#62;</para>
        </listitem>

        <listitem>
          <para>-s to &#60;xsl:sort&#62;</para>
        </listitem>

        <listitem>
          <para>-m to &#60;xsl:for-each&#62;</para>
        </listitem>

        <listitem>
          <para>-i to &#60;xsl:if&#62;</para>
        </listitem>

        <listitem>
          <para>and so on</para>
        </listitem>
      </itemizedlist>

      <para>By default subsequent options (for instance: -m) will result in
      nested corresponding XSLT elements (&#60;xsl:for-each&#62; for
      &#39;-m&#39;). To break this nesting you would have to put &#39;-b&#39;
      or &#39;--break&#39; after first &#39;-m&#39;.</para>

      <para>Below are few more examples:</para>

      <para>EXAMPLE</para>

      <para>Count all nodes in XML documents. Print input name and node count
      after it.</para>

      <programlisting>xml sel -t -f -o &#34; &#34; -v &#34;count(//node())&#34; xml/table.xml xml/tab-obj.xml</programlisting>

      <para>Output:</para>

      <programlisting>xml/table.xml 32
xml/tab-obj.xml 41</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Find XML files matching XPath expression (containing
      &#39;object&#39; element)</para>

      <programlisting>xml sel -t -m //object -f xml/table.xml xml/tab-obj.xml</programlisting>

      <para>Result output:</para>

      <programlisting>xml/tab-obj.xml</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Calculate EXSLT (XSLT extentions) XPath value</para>

      <programlisting>echo &#34;&#60;x/&#62;&#34; | xml sel -t -v &#34;math:abs(-1000)&#34;</programlisting>

      <para>Result output:</para>

      <programlisting>1000</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Adding elements and attributes using command line &#39;xml
      sel&#39;</para>

      <programlisting>echo &#34;&#60;x/&#62;&#34; | xml sel -t -m / -e xml -e child -a data -o value</programlisting>

      <para>Result Output:</para>

      <programlisting>&#60;xml&#62;&#60;child data=&#34;value&#34;/&#62;&#60;/xml&#62;</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Query XML document and produce sorted text table</para>

      <programlisting>xml sel -T -t -m /xml/table/rec -s D:N:- &#34;@id&#34; -v &#34;concat(@id,&#39;|&#39;,numField,&#39;|&#39;,stringField)&#34; -n xml/table.xml</programlisting>

      <para>Result Output:</para>

      <programlisting>3|-23|stringValue
2|346|Text Value
1|123|String Value</programlisting>

      <para>Equivalent stylesheet</para>

      <programlisting>&#60;xsl:stylesheet version=&#34;1.0&#34; xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;&#62;
&#60;xsl:output omit-xml-declaration=&#34;yes&#34; indent=&#34;no&#34; method=&#34;text&#34;/&#62;
&#60;xsl:param name=&#34;inputFile&#34;&#62;-&#60;/xsl:param&#62;
&#60;xsl:template match=&#34;/&#34;&#62;
  &#60;xsl:call-template name=&#34;t1&#34;/&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t1&#34;&#62;
  &#60;xsl:for-each select=&#34;/xml/table/rec&#34;&#62;
    &#60;xsl:sort order=&#34;descending&#34; data-type=&#34;number&#34; case-order=&#34;upper-first&#34; select=&#34;@id&#34;/&#62;
    &#60;xsl:value-of select=&#34;concat(@id,&#39;|&#39;,numField,&#39;|&#39;,stringField)&#34;/&#62;
    &#60;xsl:value-of select=&#34;&#39;&#38;#10;&#39;&#34;/&#62;
  &#60;/xsl:for-each&#62;
&#60;/xsl:template&#62;
&#60;/xsl:stylesheet&#62;</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Predefine namespaces for XPath expressions</para>

      <programlisting>xml sel -N xsql=urn:oracle-xsql -t -v /xsql:query xsql/jobserve.xsql</programlisting>

      <para>Input (xsql/jobserve.xsql)</para>

      <programlisting>$ cat xsql/jobserve.xsql
&#60;?xml version=&#34;1.0&#34;?&#62;
&#60;?xml-stylesheet type=&#34;text/xsl&#34; href=&#34;jobserve.xsl&#34;?&#62;
&#60;xsql:query connection=&#34;jobs&#34; xmlns:xsql=&#34;urn:oracle-xsql&#34; max-rows=&#34;5&#34;&#62;
  SELECT substr(title,1,26) short_title, title, location, skills
  FROM job
  WHERE UPPER(title) LIKE &#39;%ORACLE%&#39;
  ORDER BY first_posted DESC
&#60;/xsql:query&#62;</programlisting>

      <para>Result output</para>

      <programlisting>  SELECT substr(title,1,26) short_title, title, location, skills
  FROM job
  WHERE UPPER(title) LIKE &#39;%ORACLE%&#39;
  ORDER BY first_posted DESC
</programlisting>

      <para></para>

      <para>EXAMPLE</para>

      <para>Print structure of XML element using xml sel (advanced XPath
      expressions and xml sel command usage) </para>

      <programlisting>xml sel -T -t -m &#39;//*&#39; \
-m &#39;ancestor-or-self::*&#39; -v &#39;name()&#39; -i &#39;not(position()=last())&#39; -o . -b -b -n \
xml/structure.xml</programlisting>

      <para>Input (xml/structure.xml)</para>

      <programlisting>&#60;a1&#62;
  &#60;a11&#62;
    &#60;a111&#62;
      &#60;a1111/&#62;
    &#60;/a111&#62;
    &#60;a112&#62;
      &#60;a1121/&#62;
    &#60;/a112&#62;
  &#60;/a11&#62;
  &#60;a12/&#62;
  &#60;a13&#62;
    &#60;a131/&#62;
  &#60;/a13&#62;
&#60;/a1&#62;</programlisting>

      <para>Result Output:</para>

      <programlisting>a1
a1.a11
a1.a11.a111
a1.a11.a111.a1111
a1.a11.a112
a1.a11.a112.a1121
a1.a12
a1.a13
a1.a13.a131</programlisting>

      <para>This example is a good demonstration of nesting control. Here is
      corresponding XSLT:</para>

      <programlisting>&#60;xsl:stylesheet version=&#34;1.0&#34; xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;&#62;
&#60;xsl:output omit-xml-declaration=&#34;yes&#34; indent=&#34;no&#34; method=&#34;text&#34;/&#62;
&#60;xsl:param name=&#34;inputFile&#34;&#62;-&#60;/xsl:param&#62;
&#60;xsl:template match=&#34;/&#34;&#62;
  &#60;xsl:call-template name=&#34;t1&#34;/&#62;
&#60;/xsl:template&#62;
&#60;xsl:template name=&#34;t1&#34;&#62;
  &#60;xsl:for-each select=&#34;//*&#34;&#62;
    &#60;xsl:for-each select=&#34;ancestor-or-self::*&#34;&#62;
      &#60;xsl:value-of select=&#34;name()&#34;/&#62;
      &#60;xsl:if test=&#34;not(position()=last())&#34;&#62;
        &#60;xsl:value-of select=&#34;&#39;.&#39;&#34;/&#62;
      &#60;/xsl:if&#62;
    &#60;/xsl:for-each&#62;
    &#60;xsl:value-of select=&#34;&#39;&#38;#10;&#39;&#34;/&#62;
  &#60;/xsl:for-each&#62;
&#60;/xsl:template&#62;
&#60;/xsl:stylesheet&#62;</programlisting>

      <para></para>

      <para></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Transforming XML documents</title>

      <para>Here is synopsis for &#39;xml tr&#39; command:</para>

      <programlisting>XMLStarlet Toolkit: Transform XML document(s) using XSLT
Usage: xml tr [&#60;options&#62;] &#60;xsl-file&#62; {-p|-s &#60;name&#62;=&#60;value&#62;} [ &#60;xml-file-or-uri&#62; ... ]
where
   &#60;xsl-file&#62;      - main XSLT stylesheet for transformation
   &#60;xml-file&#62;      - input XML document file name (stdin is used if missing)
   &#60;name&#62;=&#60;value&#62;  - name and value of the parameter passed to XSLT processor
   -p              - parameter is XPATH expression (&#34;&#39;string&#39;&#34; to quote string)
   -s              - parameter is a string literal
&#60;options&#62; are:
   --omit-decl     - omit xml declaration &#60;?xml version=&#34;1.0&#34;?&#62;
   --show-ext      - show list of extensions
   --val           - allow validate against DTDs or schemas
   --net           - allow fetch DTDs or entities over network
   --xinclude      - do XInclude processing on document input
   --maxdepth val  - increase the maximum depth
   --html          - input document(s) is(are) in HTML format
   --catalogs      - use SGML catalogs from $SGML_CATALOG_FILES
                     otherwise XML catalogs starting from
                     file:///etc/xml/catalog are activated by default

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)

Current implementation uses libxslt from GNOME codebase as XSLT processor
(see http://xmlsoft.org/ for more details)
</programlisting>
    </sect1>

    <sect1>
      <title>Editing XML documents</title>

      <para>Here is the synopsis for &#39;xml ed&#39; command:</para>

      <programlisting>XMLStarlet Toolkit: Edit XML document(s)
Usage: xml ed &#60;global-options&#62; {&#60;action&#62;} [ &#60;xml-file-or-uri&#62; ... ]
where
  &#60;global-options&#62;  - global options for editing
  &#60;xml-file-or-uri&#62; - input XML document file name/uri (stdin is used if missing)

&#60;global-options&#62; are:
  -P (or --pf)        - preserve original formatting
  -S (or --ps)        - preserve non-significant spaces
  -O (or --omit-decl) - omit XML declaration (&#60;?xml ...?&#62;)
  -N &#60;name&#62;=&#60;value&#62;   - predefine namespaces (name without &#39;xmlns:&#39;)
                        ex: xsql=urn:oracle-xsql
                        Multiple -N options are allowed.
                        -N options must be last global options.
  --help or -h        - display help

where &#60;action&#62;
   -d or --delete &#60;xpath&#62;
   -i or --insert &#60;xpath&#62; -t (--type) elem|text|attr -n &#60;name&#62; -v (--value) &#60;value&#62;
   -a or --append &#60;xpath&#62; -t (--type) elem|text|attr -n &#60;name&#62; -v (--value) &#60;value&#62;
   -s or --subnode &#60;xpath&#62; -t (--type) elem|text|attr -n &#60;name&#62; -v (--value) &#60;value&#62;
   -m or --move &#60;xpath1&#62; &#60;xpath2&#62;
   -r or --rename &#60;xpath1&#62; -v &#60;new-name&#62;
   -u or --update &#60;xpath&#62; -v (--value) &#60;value&#62;
                          -x (--expr) &#60;xpath&#62; (-x is not implemented yet)

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</programlisting>
    </sect1>

    <sect1>
      <title>Validating XML documents</title>

      <para>Here is synopsis for &#39;xml val&#39; command:</para>

      <programlisting>XMLStarlet Toolkit: Validate XML document(s)
Usage: xml val &#60;options&#62; [ &#60;xml-file-or-uri&#62; ... ]
where &#60;options&#62;
   -w or --well-formed        - validate well-formedness only (default)
   -d or --dtd &#60;dtd-file&#62;     - validate against DTD
   -s or --xsd &#60;xsd-file&#62;     - validate against XSD schema
   -r or --relaxng &#60;rng-file&#62; - validate against Relax-NG schema
   -e or --err                - print verbose error messages on stderr
   -b or --list-bad           - list only files which do not validate
   -g or --list-good          - list only files which validate
   -q or --quiet              - do not list files (return result code only)

NOTE: XML Schemas are not fully supported yet due to its incomplete
      support in libxml (see http://xmlsoft.org)

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</programlisting>
    </sect1>

    <sect1>
      <title>Formatting XML documents</title>

      <para>Here is synopsis for &#39;xml fo&#39; command:</para>

      <programlisting>XMLStarlet Toolkit: Format XML document
Usage: xml fo [&#60;options&#62;] &#60;xml-file&#62;
where &#60;options&#62; are
   -n or --noindent            - do not indent
   -t or --indent-tab          - indent output with tabulation
   -s or --indent-spaces &#60;num&#62; - indent output with &#60;num&#62; spaces
   -o or --omit-decl           - omit xml declaration &#60;?xml version=&#34;1.0&#34;?&#62;
   -R or --recover             - try to recover what is parsable
   -D or --dropdtd             - remove the DOCTYPE of the input docs
   -C or --nocdata             - replace cdata section with text nodes
   -N or --nsclean             - remove redundant namespace declarations
   -e or --encode &#60;encoding&#62;   - output in the given encoding (utf-8, unicode...)
   -H or --html                - input is HTML
   -h or --help                - print help

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</programlisting>
    </sect1>
  </chapter>
</book>
